# 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
# 
# 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
# 
# 示例 1:
# 
# 给定数组 nums = [1,1,2], 
# 
# 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
# 
# 你不需要考虑数组中超出新长度后面的元素。
# 示例 2:
# 
# 给定 nums = [0,0,1,1,1,2,2,3,3,4],
# 
# 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
# 
# 你不需要考虑数组中超出新长度后面的元素。




class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #注意，数组是有序的，所以不会出现不连续的重复数字
        #我们需要用到同向双指针算法，首先将数组排序，这样哪些重复的整数就会被挤在一起。
        #然后用两根指针，一根指针走得
        #快一些遍历整个数组，另外一根指针，一直指向当前不重复部分的最后一个数。快指针发现一个和慢指针指向的数不
        #同的数之后，就可以把这个数丢到慢指针后面的一个位置，并把慢指针 ++
        #另一种描述：
        #遍历的索引当作快指针，设定index变量当作慢指针。
        #两指针的元素两两比较，
        #如果不相同快指针索引+1，慢指针索引+1,快指针对应的索引的元素替换为慢指针元素
        #如果相同，快指针索引+1，慢指针索引不变。
        #两指针之间的对应的索引元素都是重复的！index慢索引及之前索引元素都是不重复的。
        i = 0
        for num in nums:
            #若输入[1,2,2,3]
            #第一回循环nums[0] == nums[0],什么都不做
            #第二回nums[0] ！= nums[1],执行内容，nums[1] = nums[1]
            #第三回nums[1] == nums[2],什么都不做
            #第四回nums[1] ！= nums[3],则执行内容nums[2] == nums[3]
            #最后返回i+1
            if nums[i] != num:
                i += 1
                nums[i] = num
        return i+1
        #什么是双指针？
        #https://www.e-learn.cn/content/qita/2295183
